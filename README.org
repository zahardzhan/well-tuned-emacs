#+Title: Хорошо настроенный Emacs
#+Author: Роман Захаров
#+Email: zahardzhan@gmail.com

#+Options: HTML-Postamble:nil # HTML-страница без футера.
#+Options: ToC:nil # Оглавления нет.
#+Options: org-display-internal-link-with-indirect-buffer:t # Внутренние ссылки открываются в другом буфере.
#+Options: ^:t # Индексы TeX ^:{} и a_{b}.

Emacs [“Editor MACroS”, /​/ˈeditər ˈmakrōs/​/ → /​/ˈemaks/​/, далее ---
«эмакс»] был создан давным давно в Лаборатории искусственного
интеллекта Массачусетского технологического института
[[https://en.wikipedia.org/wiki/MIT_Computer_Science_and_Artificial_Intelligence_Laboratory][MIT AI Lab]].
Эмакс это текстовый редактор поведение и возможности которого
изменяются прямо во время написания в нем текста на языке
программирования на котором написан сам эмакс. Более того, прямо во
время написания в эмаксе текста на языке программирования на котором
написан сам эмакс изменяется поведение и возможности самого языка
программирования на котором написан эмакс. Все это делает эмакс самым
гибким и универсальным текстовым редактором в сравнении с любым
другим.

Эмакс развивается уже несколько десятилетий. Каждый год сотни человек
добавляют в него все новые и новые возможности. Обычно это небольшие
фрагменты обособленной функциональности под нужды конкретного
пользователя. Однако, общий объем и широта охвата этих улучшений со
временем превратили мощный текстовый редактор во всеобъемлющую
кроссплатформенную программную среду в которой можно делать абсолютно
все что угодно, если это хотя бы немного относится к работе с текстом.

Универсальность эмакса играет вам на руку, если вы понимаете как он
устроен: вы можете делать тысячу разных дел через единый интерфейс в
котором все состоит из текста во всех его проявлениях. Возможно, это
выглядит архаично с точки зрения представлений о современном
пользовательском интерфейсе, но это не так; хотя бы потому что
современные интерфейсы не раскрывают силу простого текста в полной
мере. Чтобы стать грамотным пользователем эмакса, вам придется понять
его концепцию и внутреннее устройство, а это значит --- приобщиться к
культуре хакеров 70-х годов прошлого века. Новичков такое положение
дел пугает, но все не так плохо: эмакс сложен только для сложных
задач, а для простых задач он прост, все зависит от ваших
потребностей. Начать знакомство с ним лучше с общего обзора
“[[http://www.gnu.org/software/emacs/tour/][A Guided Tour of Emacs]]”
на сайте [[http://www.gnu.org/philosophy/free-sw.ru.html][свободной]]
[[http://www.gnu.org][операционной системы GNU]].

Ричард Столлман описывает историю возникновения эмакса в статье
«[[http://www.gnu.org/gnu/rms-lisp.ru.html][Мой опыт работы с лиспом и развитие GNU Emacs]]»;
эта история тесно связана с не менее интересной
[[http://www.gnu.org/gnu/thegnuproject.ru.html][историей проекта GNU]]
из которой можно узнать, что
[[https://www.gnu.org/software/emacs/][GNU Emacs]] был первым проектом в
проекте GNU. Суть того что из себя представляет эмакс подробно
изложена в документе
“[[https://www.gnu.org/software/emacs/emacs-paper.html][EMACS: The Extensible, Customizable Display Editor]]”
написанном в 1981 году --- и за прошедшие годы эта суть ничуть не
изменилась.
                                        
Расширяемость эмакса это его благословение и проклятье. Конечно, в
стандартной поставке эмакс хорош, но не так хорош как мог бы быть. Вы
не ограничены решениями разработчиков, и если вам нужна
функциональность которой в эмаксе нет, вы можете добавить ее сами:
достаточно просто открыть эмакс и подробно её описать. В конце концов
все возможности эмакса по редактированию текста это всего лишь текст
описывающий что делать с текстом, и вы можете изменить этот текст в
любое время точно так же как и любой другой, тем самым изменив
возможности эмакса. Потенциально его возможности безграничны, но чтобы
ими воспользоваться придется взяться за настройку, а это подразумевает
умение программировать и плотное общение с сообществом.

Настройка эмакса это своего рода декоративно-прикладное искусство; для
каждого конкретного пользователя она заключается в составлении
лисп-программы из фрагментов лисп-кода взятых из множества
разрозненных источников. Никакого другого способа в принципе нет,
поэтому перед погружением в эту тему следует освоиться с
программированием вообще и программированием на лиспе в
частности.
[[https://en.wikipedia.org/wiki/Lisp_(programming_language)][Лисп]]
это древнейший из используемых языков программирования очень высокого
уровня, а также простейший из известных человечеству способов
организации вычислений из /символов/, /структур данных/ и /функций/
(открытых математиками в 1936 году).

В изучении программирования поможет книга
«[[http://newstar.rinet.ru/~goga/sicp/sicp-ru-screen.pdf][Структура и интерпретация компьютерных программ]]» ---
это вводный курс по информатике в MIT. В деле написания программ для
эмакса пригодится учебник
«[[http://alexott.net/ru/emacs/elisp-intro/elisp-intro-ru.html][Введение в программирование на Emacs Lisp]]»,
справочник
“[[https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html][GNU Emacs Lisp Reference Manual]]”,
и брошюра “[[http://clqr.berlios.org][Common Lisp Quick Reference]]”.

Эмакс совершенно точно не та программа за изучение которой стоит
браться только ради того, чтобы редактировать в нем текст. Его следует
воспринимать скорее как живой артефакт и культурный памятник более
цивилизованной эпохи. Изучение эмакса окажется пустой тратой времени
если вы не программируете и не хотите иметь ничего общего с этой
деятельностью, но если это не так, ничего лучше эмакса вы не найдете.

Обычно создание удобной для себя конфигурации и ее последующая доводка
растягивается на долгое время. Можно облегчить себе жизнь и установить
фреймворк в котором все основные настройки выполнены в соответствии с
видением автора фреймворка, и вам даже не придется править исходный
код для того чтобы просто пользоваться эмаксом в свое
удовольствие. Самые популярные фреймворки на сегодня:
[[https://github.com/syl20bnr/spacemacs][Spacemacs]],
[[https://github.com/bbatsov/prelude][Emacs Prelude]],
[[https://github.com/eschulte/emacs24-starter-kit][Eschulte Literate Emacs Starter Kit]],
[[https://github.com/overtone/emacs-live][Overtone Emacs Live]],
[[https://github.com/purcell/emacs.d][Purcell emacs.d]],
[[https://github.com/xiaohanyu/oh-my-emacs][Oh My Emacs]].

Все будет хорошо до тех пор пока вы не захотите встроить в эмакс некую
невероятную функциональность которой в выбранном фреймворке нет, и
тогда вам придется вручную интегрировать некий код не только в эмакс,
но и во фреймворк, а для этого нужно будет разобраться с его
внутренним устройством, что сводит все его достоинства на нет. К
такому выводу пришел автор
[[https://github.com/technomancy/emacs-starter-kit][Emacs Starter Kit]]
(см. [[http://www.google.com/search?q=meet+emacs+pluralsight+torrent][Meet Emacs]]),
когда закрыл свой проект после шести лет развития:

#+BEGIN_QUOTE
Старые версии Emacs Starter Kit были единой-для-всех кодовой базой
заменяющей содержимое директории ~/.emacs.d. Это было очень популярное
решение, но большая связка бессвязной функциональности вела к тому,
что пользователь просто привыкал к ней ничего не понимая. Когда
некоторые вещи ломались или вели себя не так как вам хотелось, вы и
понятия не имели где их исправить.

Я понял, что пользователям лучше подходят маленькие /пакеты/ дающие
желаемую функциональность. Вместо свалки кода, Emacs Starter Kit
сделался небольшим руководством. Как пользователю Emacs, вам предстоит
искать новые фрагменты эмакс-лисп-кода, интегрировать их,
конфигурировать, и даже писать свои собственные. Emacs Starter Kit
поможет вам советами где начать и что именно искать, но сборка годной
конфигурации это личное дело каждого.
#+END_QUOTE

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html][Система пакетов]]
[[[info:Emacs#Packages][инфо]]]
эмакса это встроенная в него лисп-программа
[см. [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/package.el][исходник на github]];
[[elisp:list-packages][открыть графический интерфейс системы пакетов в эмаксе]] --- [[elisp:list-packages][M-x list-packages]]]
которая автоматически интегрирует в эмакс другие лисп-программы из
интернета. Система пакетов работает независимо от операционной системы
под которой запущен редактор, она сама отслеживает зависимости между
лисп-программами и заботится об их обновлении. Разработку этой ситемы
[[http://tromey.com/blog/?p=325][начал]]
[[http://www.emacswiki.org/emacs/TomTromey][Том Тромей]] в 2007 году,
в 2012 она была включена в состав Emacs 24.1; пик популярности Emacs
Starter Kit пришелся именно на эти годы, то есть по большому счету
сообщество [[http://technomancy.us/153][использовало]] его для
разработки системы пакетов.

Как бы там ни было, личная конфигурация эмакса по своей природе была
есть и будет просто большой кучей бессвязаного кода, и лучший способ
справиться с этим --- оставить все как есть; или превратить эту кучу в
руководство которое будет
[[http://www.literateprogramming.com/knuthweb.pdf][объяснять причины]]
(в первую очередь чтобы не забыть самому) по которым тот или иной
фрагмент находится в этой куче, а потом сделать так чтобы это
руководство само превращало себя в лисп-программу и выполняло
конфигурацию эмакса при запуске. А также пересобирало само себя при
изменении и скачивало новые версии себя из удаленных
источников. Почему бы и нет. Это же руководство для настройки эмакса
мышью в лучших традициях Стэнфорда и MIT.

[[elisp:org-babel-tangle][Превратить это руководство в лисп-программу инициализации эмакса]]
.emacs или init.el (/сплести/ программу --- /tangle/) очень просто, достаточно
[[https://gitlab.com/zahardzhan/well-tuned-emacs/raw/master/README.org][скачать свежую версию этого руководства]],
открыть ее в эмаксе и выполнить команду [[elisp:org-babel-tangle][M-x org-babel-tangle]].
В результате из фрагментов лисп-кода в этом руководстве будет создана
[[http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][лисп-программа инициализации эмакса]]
[[[info:Emacs#Init File][инфо]], [[http://www.emacswiki.org/emacs/InitFile][вики]]]
которую эмакс будет автоматически выполнять при каждом запуске.  В
общем виде программа инициализации выглядит так:

#+header: :noweb no-export
#+header: :shebang ;;; Automatically generated by “Well Tuned Emacs” -*- lexical-binding: t -*-
#+begin_src elisp :tangle (identity user-init-file) 
  <<header>>
  <<requirements>>
  <<customize-well-tuned-emacs>>
  <<customize-customize-and-apply-customizations>>
  <<try-to-download-this-reference-when-it-is-missing>>
  (if
      <<this-reference-is-in-its-place-and-is-newer-than-user-init-file>>
      <<tangle-this-reference-into-user-init-file-and-then-load-it-again>>
    (progn
      <<initialize-package-system-and-install-user-selected-packages>>
      <<load-packages-and-apply-advanced-customizations>>
      <<fix-some-bugs>>
      ))
  <<footer>>
#+end_src

Перед написанием кода на эмакс лиспе, следует немного обновить сам
язык программирования. Эмакс лисп это древнейший из современных
лиспов, созданный в темный период между возникновением
[[http://www-formal.stanford.edu/jmc/recursive/recursive.html][лиспа как концепции теории вычислений]],
и первыми двумя классическими дизайнами лиспа: Common Lisp и Scheme;
сама концепция лиспа так же стара для него, как он сам по отношению к
современному Common Lisp'у, а современный Common Lisp в свою
очередь --- по отношению к современной Clojure. Эмакс лисп старомоден,
его выразительные средства скудны, тем не менее, это полноценный лисп
и он может с легкостью дополнить свои возможности основными языковыми
средствами Common Lisp, просто выполнив относительно небольшую
встроенную в эмакс лисп-программу
[[http://www.gnu.org/software/emacs/manual/html_mono/cl.html][GNU Emacs Common Lisp Emulation]]
[[[info:cl#Top][инфо]]]. Стоит отметить, что сообщество
[[http://xahlee.blogspot.ru/2012/06/controversy-of-common-lisp-package-in.html][очень неоднозначно]]
относится к этой лисп-программе; например, Столлман выступает
[[http://lists.gnu.org/archive/html/emacs-devel/2012-06/msg00056.html][против]]
ее включения в эмакс.

#+name: requirements
#+begin_src elisp
  (require 'cl-lib)
#+end_src

В 24-й версии эмакса в эмакс-лиспе появилась поддержка
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Lexical-Binding.html#Using-Lexical-Binding][лексической области видимости и замыканий]]
([[http://library.readscheme.org/page1.html][как в Scheme образца 1975 года]]).
Лексическая область видимости делает программу инициализации более
изящной, быстрой и надежной. Первая строка в файле инициализации
устанавливает
[[http://www.gnu.org/software/emacs/manual/html_node/emacs/Specifying-File-Variables.html#Specifying-File-Variables][локальную переменную буфера]]
и активирует соответствующую семантику языка
программирования.

#+begin_src elisp :tangle no
  ;;; Automatically generated by “Well Tuned Emacs” -*- lexical-binding: t -*-
#+end_src

Во время запуска эмакс выполняет
[[elisp:(describe-function 'command-line)][одну из девяти возможных программ инициализации]]
[см. [[https://github.com/emacs-mirror/emacs/blob/master/lisp/startup.el#L1158][исходник на github]],
[[https://github.com/emacs-mirror/emacs/blob/master/src/lread.c#L4556][user-init-file и load в C-коде]]]
(на самом деле их больше, но другие варианты не кроссплатформенны).
Нам нужно определить какую именно исходную лисп-программу
инициализации мы возьмем за основу, в порядке приоритета: =~/_emacs=
(/устаревший --- для MS-DOS/), =~/.emacs=, =~/.emacs.el=,
=~/.emacs.d/init.el=.

| user-init-file while init      | user-init-file after init                     | actual-user-init-file       |
|--------------------------------+-----------------------------------------------+-----------------------------|
| =nil= emacs -q/-​-no-init-file  | =nil=                                         | prefer =~/.emacs.d/init.el= |
| =~/.emacs= relative by default | =~/.emacs= relative by default                | =~/.emacs=                  |
| =~/_emacs=                     | =~/_emacs=                                    | =~/_emacs=                  |
| =~/_emacs.el=                  | =~/_emacs.el=                                 | =~/_emacs.el=               |
| =~/_emacs.elc=                 | =~/_emacs.el= or =~/_emacs= or =~/_emacs.elc= | =~/_emacs.el= or =~/_emacs= |
| =~/.emacs=                     | =~/.emacs=                                    | =~/.emacs=                  |
| =~/.emacs.el=                  | =~/.emacs.el=                                 | =~/.emacs.el=               |
| =~/.emacs.elc=                 | =~/.emacs.el= or =~/.emacs= or =~/.emacs.elc= | =~/.emacs.el= or =~/.emacs= |
| =~/.emacs.d/init.el=           | =~/.emacs.d/init.el=                          | =~/.emacs.d/init.el=        |
| =~/.emacs.d/init.elc=          | =~/.emacs.d/init.el= or =~/.emacs.d/init.elc= | =~/.emacs.d/init.el=        |

#+name: user-init-file-names
#+begin_src elisp
  (default "~/.emacs")
  (~/_emacs (file-truename "~/_emacs"))
  (~/_emacs.el (file-truename "~/_emacs.el"))
  (~/_emacs.elc (file-truename "~/_emacs.elc"))
  (~/.emacs (file-truename "~/.emacs"))
  (~/.emacs.el (file-truename "~/.emacs.el"))
  (~/.emacs.elc (file-truename "~/.emacs.elc"))
  (~/.emacs.d/init.el (file-truename "~/.emacs.d/init.el"))
  (~/.emacs.d/init.elc (file-truename "~/.emacs.d/init.elc"))
#+end_src

#+name: customize-well-tuned-emacs
#+begin_src elisp
     (defvar actual-user-init-file
       (let (
             <<user-init-file-names>>
             )
         (or (when (equal user-init-file nil)
               (or (cl-find-if #'file-exists-p 
                       (list ~/.emacs.d/init.el ~/_emacs ~/_emacs.el ~/.emacs ~/.emacs.el))
                   ~/.emacs.d/init.el))
             (when (equal user-init-file default)
               ~/.emacs)
             (when (file-equal-p user-init-file ~/_emacs)
               ~/_emacs)
             (when (file-equal-p user-init-file ~/_emacs.el)
               ~/_emacs.el)
             (when (file-equal-p user-init-file ~/_emacs.elc)
               (or (when (file-exists-p ~/_emacs.el)
                    ~/_emacs.el)
                   ~/_emacs))
             (when (file-equal-p user-init-file ~/.emacs)
               ~/.emacs)
             (when (file-equal-p user-init-file ~/.emacs.el)
               ~/.emacs.el)
             (when (file-equal-p user-init-file ~/.emacs.elc)
               (or (when (file-exists-p ~/.emacs.el)
                    ~/.emacs.el)
                   ~/.emacs))
             (when (or (file-equal-p user-init-file ~/.emacs.d/init.el)
                       (file-equal-p user-init-file ~/.emacs.d/init.elc))
               ~/.emacs.d/init.el))))
#+end_src

Исходный код лисп-программы инициализации в файле
[[elisp:(find-file actual-user-init-file)][actual-user-init-file]]
вторичен по отношению к этому руководству, это не более чем
автоматически сгенерированная из него программа. Но что если
руководства не окажется в директории с настройками эмакса, и
лисп-программа инициализации не сможет регенерировать себя? В таком
случае программа инициализации должна попытаться скачать руководство
из интернета.

#+name: try-to-download-this-reference-when-it-is-missing
#+begin_src elisp
  (unless (file-exists-p well-tuned-emacs-reference-file)
    (condition-case error-signal
        (with-temp-file well-tuned-emacs-reference-file
          (url-insert-file-contents well-tuned-emacs-reference-url))
      (error
       (cl-destructuring-bind (error-symbol . error-data) error-signal
         (message "Failed to download %s and save it as %s: %s - %s."
                   well-tuned-emacs-reference-url
                   well-tuned-emacs-reference-file
                   error-symbol error-data))
       (when (file-exists-p well-tuned-emacs-reference-file)
         (delete-file well-tuned-emacs-reference-file :move-to-trash)))))
#+end_src

Прежде мы должны условиться, что это руководство будет храниться в
определенном месте, по умолчанию --- в той же директории, что и
актуальная лисп-программа инициализации эмакса; под определенным
именем, по-умолчанию ---
[[elisp:(find-file (concat (file-name-directory user-init-file) "README.org"))][README.org]].
Так же нам должен быть известен адрес свежей версии этого руководства
в интернете. Встроенное в эмакс средство
[[http://www.gnu.org/software/emacs/manual/html_node/elisp/Customization.html#Customization][Customize]]
позволит сделать настройки расположения файлов руководства полностью
независимыми от прописанных в этом руководстве значений
по-умолчанию. Потом эти настройки можно будет изменить в самом эмаксе
и сохранить их значения на будущее, не меняя ни фрагменты кода в этом
руководстве, ни код в сгенерированной лисп-программе
инициализации. Для этого создадим в группе кастомизации
[[elisp:(customize-group-other-window 'initialization)][Initialization]]
подгруппу
[[elisp:(customize-group-other-window 'well-tuned-emacs)][Well Tuned Emacs]].

#+name: customize-well-tuned-emacs
#+begin_src elisp
  (defgroup well-tuned-emacs nil
    "Well Tuned Emacs initialization and customization settings."
    :link '(url-link "https://gitlab.com/zahardzhan/well-tuned-emacs")
    :version "25.0.50.1"
    :group 'initialization)
#+end_src

Добавим в эту группу две пользовательские настройки.

[[elisp:(customize-group-other-window 'emacs)][Emacs]]⊲
[[elisp:(customize-group-other-window 'environment)][Environment]]⊲
[[elisp:(customize-group-other-window 'initialization)][Initialization]]⊲
[[elisp:(customize-group-other-window 'well-tuned-emacs)][Well Tuned Emacs]]⊲
[[elisp:(customize-variable-other-window 'well-tuned-emacs-reference-file)][Well Tuned Emacs Reference File]]
← файл [[elisp:(find-file (concat (file-name-directory user-init-file) "README.org"))][README.org]]
в [[elisp:(dired (file-name-directory actual-user-init-file))][директории с актуальной лисп-программой инициализации эмакса]].
Расположение файла этого руководства. Для обеспечения переносимости
путей файлов между разными средами исполнения эмакс-лисп кода их
следует указывать в формате
[[https://en.wikipedia.org/wiki/Path_(computing)][POSIX]], это
позволит использовать один-и-тот-же файл одновременно с двух
запущенных в разных средах экземпляров эмакса (например
Windows/Cygwin/VMware).

| actual-user-init-file                                      | well-tuned-emacs-reference-file                  |
|------------------------------------------------------------+--------------------------------------------------|
| =~/.emacs= or =~/.emacs.el= or =~/_emacs= or =~/_emacs.el= | =~/README.org= or =~/.emacs.d/README.org=        |
| =~/.emacs.d/init.el=                                       | prefer =~/.emacs.d/README.org= to =~/README.org= |

#+name: customize-well-tuned-emacs
#+begin_src elisp
  (defcustom well-tuned-emacs-reference-file
    (let* (
           <<user-init-file-names>>
           (~/readme (file-truename (concat (file-name-as-directory "~") "README.org")))
           (~/.emacs.d/readme (file-truename (concat user-emacs-directory "README.org"))))
      (ignore default ~/_emacs.elc  ~/.emacs.elc ~/.emacs.d/init.elc)
      (or (when (cl-find actual-user-init-file (list ~/.emacs ~/.emacs.el ~/_emacs ~/_emacs.el) :test #'equal)
            (or (when (file-exists-p ~/readme)
                 ~/readme)
                ~/.emacs.d/readme))
          (when (equal actual-user-init-file ~/.emacs.d/init.el)
            (or (when (file-exists-p ~/.emacs.d/readme)
                 ~/.emacs.d/readme)
                (when (file-exists-p ~/readme)
                 ~/readme)
                ~/.emacs.d/readme))))
    "The Well Tuned Emacs Reference file."
    :type 'file
    :version "25.0.50.1"
    :group 'well-tuned-emacs)
#+end_src

[[elisp:(customize-group-other-window 'emacs)][Emacs]]⊲
[[elisp:(customize-group-other-window 'environment)][Environment]]⊲
[[elisp:(customize-group-other-window 'initialization)][Initialization]]⊲
[[elisp:(customize-group-other-window 'well-tuned-emacs)][Well Tuned Emacs]]⊲
[[elisp:(customize-variable-other-window 'well-tuned-emacs-reference-url)][Well Tuned Emacs Reference URL]]
← https://gitlab.com/zahardzhan/well-tuned-emacs/raw/master/README.org.
Адрес свежей версии этого руководства в интернете.

#+name: customize-well-tuned-emacs
#+begin_src elisp
  (defcustom well-tuned-emacs-reference-url
    "https://gitlab.com/zahardzhan/well-tuned-emacs/raw/master/README.org"
    "The Well Tuned Emacs Reference File on the internet."
    :type 'string
    :version "25.0.50.1"
    :group 'well-tuned-emacs)
#+end_src

Лисп-программа
[[http://www.gnu.org/software/emacs/manual/html_node/elisp/Customization.html#Customization][Customize]]
[[[elisp:customize][открыть её графический интерфейс в эмаксе]] --- [[elisp:customize][M-x customize]]],
ставшая частью эмакса в середине девяностых --- это краеугольный
камень всей системы пользовательских настроек. Парадоксально, но
подавляющее большинство фреймворков и личных настроек, доступных в
сети, всеми силами избегают настройки эмакса с помощью встроенного в
него интерфейса предназначенного именно для этой цели. Люди
предпочитают настраивать эмакс написанием своего лисп-кода даже в тех
случаях, когда этот лисп-код уже предусмотрительно написан, отлажен и
задокументирован разработчиками лисп-программ, которые пользователь
пытается настроить. Этот
[[http://c2.com/cgi/wiki?NotInventedHereSyndrome][фатальный недостаток]]
распространен повсеместно, но большинство пользователей эмакса считает
такое положение дел нормальным.

Истина состоит в том, что GNU Emacs 25 имеет 3440 стандартных
настройки в конфигурации по-умолчанию. Все они хорошо организованны,
задокументированны и доступны для поиска и изменения в простом удобном
и непривычном псевдографическом интерфейсе. Эти настроки сохраняются
между сессиями эмакса, и многие из них выполнены в виде специфических
лисп-программ. Подключение дополнительных модулей и пакетов расширений
эмакса может запросто увеличить количество таких настроек до пяти
тысяч. К чему приведет попытка изменения нескольких тысяч параметров
управляемых лисп-кодом, меняющимся от версии-к-версии, написанием
своего лисп-кода? Она практически неизбежно приведет к
[[http://www.emacswiki.org/emacs/DotEmacsBankruptcy][конфигурационному апокалипсису]].
Поэтому здесь и далее, и везде где только можно, я буду использовать
систему Customize.

[[elisp:(customize-group-other-window 'emacs)][Emacs]]⊲
[[elisp:(customize-group-other-window 'help)][Help]]⊲
[[elisp:(customize-group-other-window 'customize)][Customize]]⊲
[[elisp:(customize-variable-other-window 'custom-file)][Custom File]]
← [[file:~/.emacs.d/custom.el][~/.emacs.d/custom.el]].
По-умолчанию Customize хранит свои данные в файле с исходным кодом
лисп-программы инициализации эмакса; если мы переплетем этот файл ---
все наши настройки пропадут. В Customize можно выполнить настройку
самой Customize, но фактически эта программа не может изменить место
хранения своих данных, при том что такой параметр в ней есть ---
информация о том какой файл будет загружен хранится в самом этом
файле, таким образом эта информация недоступна извне. Мы будем хранить
настройки выполненные программой Customize в файле custom.el в
директории ~/.emacs.d.

#+name: customize-customize-and-apply-customizations
#+begin_src elisp
  (let ((~/.emacs.d/custom.el (concat user-emacs-directory "custom.el")))
    (setq custom-file ~/.emacs.d/custom.el)
    (when (file-exists-p custom-file)
      (load custom-file))
    (unless (equal ~/.emacs.d/custom.el (car (get 'custom-file 'saved-value)))
      (add-hook 'after-init-hook
        (defun save-custom-file-location-in-custom-file ()
          (customize-save-variable 'custom-file ~/.emacs.d/custom.el)))))
#+end_src

Ниже код вида (add-hook 'after-init-hook (defun ... () ... )) появится
еще несколько раз, поэтому имеет смысл генерировать его с помощью
макроса.

#+name: customize-customize-and-apply-customizations
#+begin_src elisp
  (defmacro customize-save-variable-after-init (var)
   `(add-hook 'after-init-hook
      (defun ,(make-symbol (concat "customize-save-variable-" (symbol-name var))) ()
        (customize-save-variable ',var ,var))))
#+end_src

Многие режимы не активируются сами по себе при запуске эмакса, даже
при том что в сохраненных настройках явно указано, что они должны быть
активны. Поэтому после загрузки режимов приходится напоминать им об
актививации.

#+name: customize-customize-and-apply-customizations
#+begin_src elisp
  (defun reinstate-mode (mode)
    (when (car (get mode 'saved-value))
      (funcall mode 1)))
#+end_src

Чтобы не /переплетать/ программу инициализации эмакса вручную после
каждого редактирования этого руководства, сделаем так, что программа
будет переплетать сама себя прямо во время запуска эмакса, если
руководство было изменено после изменения программы.

#+name: this-reference-is-in-its-place-and-is-newer-than-user-init-file
#+begin_src elisp
  (when (file-exists-p well-tuned-emacs-reference-file)
    (or (not (file-exists-p actual-user-init-file))
        (file-newer-than-file-p well-tuned-emacs-reference-file actual-user-init-file)))
#+end_src

По всей видимости нет никакого тривиального способа заставить
лисп-программу org-babel-tangle должным образом обрабатывать свойство
заголовка блоков кода :tangle и связанный с ним аргумент target-file,
указывающий в какой именно файл нужно сохранить сплетенную программу.
Применим небольшой хак с перекрытием значения глобальной переменной
user-init-file в динамической области видимости --- таким образом мы
укажем всем сторонним лисп-программам имя файла нашей новой программы
инициализации на время сплетения и выполнения этой программы.

#+name: tangle-this-reference-into-user-init-file-and-then-load-it-again
#+begin_src elisp
  (progn
    (require 'ob-tangle)
    (message "Tangling %s → %s." well-tuned-emacs-reference-file actual-user-init-file)
    (let ((user-init-file actual-user-init-file))
      (org-babel-with-temp-filebuffer well-tuned-emacs-reference-file
        (org-babel-tangle))
      (load-file user-init-file)))
#+end_src

Как вариант, во время загрузки лисп-программы инициализации мы можем
ее скомпилировать. Для этого нам понадобится лисп-программа
байт-компиляции лисп-программ bytecomp. Следующая строка кода это
своего рода шутка (нет) --- она загружает лисп-программу байт-компиляции
лисп-программ во время байт-компиляции нашей лисп-программы
лисп-программой байт-компиляции лисп-программ.

#+name: requirements
#+begin_src elisp
  (cl-eval-when (compile) (require 'bytecomp))
#+end_src

При интерпретации лисп-программы инициализации эмакса программа для
сплетения этого руководства ob-tangle загружается непосредственно
перед её использованием, и это не создает никаких проблем. Однако
программа компиляции по возможности должна знать обо всех сторонних
лисп-программах, которые могут быть загружены во время выполнения
скомпилированной программы инициализации эмакса.

#+name: requirements
#+begin_src elisp
  (cl-eval-when (compile) (require 'ob-tangle))
#+end_src

Определим переменную-условие компиляции программы инициализации эмакса
well-tuned-emacs-compile-user-init-file как опцию в группе настроек
этого руководства.

[[elisp:(customize-group-other-window 'emacs)][Emacs]]⊲
[[elisp:(customize-group-other-window 'environment)][Environment]]⊲
[[elisp:(customize-group-other-window 'initialization)][Initialization]]⊲
[[elisp:(customize-group-other-window 'well-tuned-emacs)][Well Tuned Emacs]]⊲
[[elisp:(customize-variable-other-window 'well-tuned-emacs-compile-user-init-file)][Well Tuned Emacs Compile User Init File]]
←
[[elisp:(customize-save-variable 'well-tuned-emacs-compile-user-init-file t)][компилировать]] или
[[elisp:(customize-save-variable 'well-tuned-emacs-compile-user-init-file nil)][не компилировать]]
лисп-программу инициализации эмакса. При автоматической установке
сохраненного значения этой опции системой Customize, а также при
ручном включении/отключении этой опции в через интерфейс Customize,
эмакс должен соответственно скомпилировать, или удалить
скомпилированную программу инициализации. Для этого нам нужно написать
функцию которая позаботится обо всем при изменении значения этой опции.

#+name: customize-well-tuned-emacs
#+begin_src elisp
  (defcustom well-tuned-emacs-compile-user-init-file nil
    "Compile or don't compile well-tuned Emacs user init file."
    :type 'boolean
    :set
    <<set-well-tuned-emacs-compile-user-init-file>>
    :version "25.0.50.1"
    :group 'well-tuned-emacs)
#+end_src

Загрузка эмакса становится довольно запутанной если добавить в нее
возможность компиляции файла инициализации. С учетом описания того как
происходит
[[http://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation][компиляция лисп-программ эмакса]],
[[http://www.gnu.org/software/emacs/manual/html_node/elisp/Startup-Summary.html][запуск эмакса]],
[[http://www.gnu.org/software/emacs/manual/html_node/elisp/How-Programs-Do-Loading.html#How-Programs-Do-Loading][загрузка лисп-программ эмакса]],
и того что происходит в нашей программе инициализации, мы должны
учесть шесть возможных последовательностей выполнения лисп-программ
при запуске эмакса:

1. el→emacs [safe]
2. el→tangle→el→emacs [safe]
3. el→tangle→compile→elc→emacs [safe]
4. elc→emacs [safe]
5. elc→tangle→el↛emacs [unsafe (package-initialize)⇝user-init-file⇎load-file-name]
6. elc→tangle→compile↛elc→emacs [unsafe (byte-compile elc)⇝cannot rename elc↦elc]

Компилировать или удалять программу инициализации прямо во время ее
выполнения рискованно, поэтому шесть возможных вариантов развития
событий в итоге сводятся к четырем.

|              | compile                                                      | delete                        |
|--------------+--------------------------------------------------------------+-------------------------------|
| *while init* | compile after init                                           | delete after init             |
| *after init* | compile =el= when there is no =elc= or =elc= older than =el= | delete =elc= if there is =el= |

Таким образом, когда мы устанавливаем значение этой опции во время
инициализации эмакса, выполнение соответствующих действий
откладывается на потом.

#+name: set-well-tuned-emacs-compile-user-init-file
#+begin_src elisp
  (progn 
    (defun well-tuned-emacs-compile-user-init-file ()
      (let ((while-init-time (not after-init-time)))
        (cond (while-init-time
               (add-hook 'after-init-hook #'well-tuned-emacs-compile-user-init-file))
              (after-init-time
               (require 'bytecomp)
               (if well-tuned-emacs-compile-user-init-file
                   <<compile-el-when-there-is-no-elc-or-elc-older-than-el>>
                 <<delete-elc-if-there-is-el>>
                 )))))
    (lambda (symbol value)
      (set symbol value)
      (well-tuned-emacs-compile-user-init-file)))
#+end_src

Компилируем лисп-программу инициализации только если скомпилированная
программа старее, или её вовсе нет.

#+name: compile-el-when-there-is-no-elc-or-elc-older-than-el
#+begin_src elisp
  (when (file-exists-p actual-user-init-file)
    (byte-recompile-file actual-user-init-file nil 0))
#+end_src

Просто удаляем скомпилированную программу инициализации, если у нас
есть исходная программа инициализации.

#+name: delete-elc-if-there-is-el
#+begin_src elisp
  (when (and (file-exists-p actual-user-init-file)
             (file-exists-p (byte-compile-dest-file actual-user-init-file)))
    (delete-file (byte-compile-dest-file actual-user-init-file)))
#+end_src

Осталось нанести последний штрих и общая программа инициализации
эмакса будет готова. Система пакетов вошла в состав эмакса несколько
лет назад, но все еще активно развивается и в некоторых местах требует
ручного вмешательства. Если мы ею воспользуемся, система пакетов
добавит код своей инициализации в сгенерированную программу
инициализации эмакса. Чтобы этого избежать, достаточно добавить этот
код самим, и сразу после этого мы можем
[[elisp:list-packages][выбрать и установить свои любимые пакеты]].

#+name: initialize-package-system-and-install-user-selected-packages
#+begin_src elisp
  <<initialize-package-system>>
  <<package-system-backports>>
  <<make-sure-melpa-is-used-as-one-of-community-package-archives>>
  <<make-sure-use-package-package-will-be-present>>
  (unless (cl-every #'package-installed-p package-selected-packages)
    (package-refresh-contents)
    (package-install-selected-packages))
  (require 'use-package)
  <<setup-use-package>>
#+end_src

В обычных условиях для инициализации системы пакетов было бы
достаточно одного единственного вызова функции (package-initialize),
но особенности работы провайдера «Ростелеком» иногда приводят к
повреждению кеша архивов. Поэтому при возникновении ошибки
определенного типа кеш нужно очистить и затем попытаться провести
повторную инициализацию системы пакетов.

#+name: initialize-package-system
#+begin_src elisp
  (condition-case nil
      (package-initialize)
    (wrong-type-argument
       (cl-loop for (archive . _location) in package-archives
                with rel-path = "archives/%s/archive-contents"
                for archive-contents = (expand-file-name (format rel-path archive) package-user-dir)
                when (file-exists-p archive-contents) do (delete-file archive-contents))
       (package-initialize)))
#+end_src

Конечно, перед автоматической установкой пакетов эмакс должен знать
какие именно пакеты устанавливать и откуда их брать.

[[elisp:(customize-group-other-window 'emacs)][Emacs]]⊲
[[elisp:(customize-group-other-window 'applications)][Applications]]⊲
[[elisp:(customize-group-other-window 'package)][Package]]⊲
[[elisp:(customize-variable-other-window 'package-archives)][Package Archives]]
← адреса архивов. По-умолчанию эмакс устанавливает пакеты из
официального архива [[http://elpa.gnu.org/][GNU ELPA]]. В этом архиве
мало пакетов, но они надежные и доверенные. В неофициальных архивах
[[https://melpa.org][MELPA]][[[elisp:(progn (unless (featurep 'cl-lib) (require 'cl-lib))(unless (featurep 'package) (require 'package))(customize-save-variable 'package-archives (cl-pushnew (cons "melpa" "http://melpa.milkbox.net/packages/") package-archives :test #'equal)))][добавить]]] и
[[https://marmalade-repo.org/][Marmalade]][[[elisp:(progn (unless (featurep 'cl-lib) (require 'cl-lib)) (unless (featurep 'package) (require 'package))(customize-save-variable 'package-archives (cl-pushnew (cons "marmalade" "http://marmalade-repo.org/packages/") package-archives :test #'equal)))][добавить]]]
пакетов гораздо больше, но они менее качественные в плане лицензионной
чистоты и гарантий безопасности.
[[http://emacs.stackexchange.com/questions/268/what-are-the-practical-differences-between-the-various-emacs-package-repositorie][Различия между этими архивами несущественны]],
но лично я предпочитаю MELPA, потому что он [[https://github.com/milkypostman/melpa][хостится на гитхабе]].

#+name: make-sure-melpa-is-used-as-one-of-community-package-archives
#+begin_src elisp
  (let ((melpa-location "http://melpa.milkbox.net/packages/"))
    (when (cl-loop for (_archive . location) in package-archives never (equal location melpa-location))
      (cl-pushnew  (cons "melpa" melpa-location) package-archives :test #'equal)
      (customize-save-variable-after-init package-archives)))
#+end_src

[[elisp:(customize-group-other-window 'emacs)][Emacs]]⊲
[[elisp:(customize-group-other-window 'applications)][Applications]]⊲
[[elisp:(customize-group-other-window 'package)][Package]]⊲
[[elisp:(customize-variable-other-window 'package-selected-packages)][Package Selected Packages]]
← имена вручную установленных пакетов. Каждый раз когда пользователь
эмакса лично выбирает и устанавливает нужный ему пакет, эмакс
сохраняет имя этого пакета в списке-значении переменной-опции
package-selected-packages. Сама эта настройка
[[http://endlessparentheses.com/new-in-package-el-in-emacs-25-1-user-selected-packages.html][появились только в GNU Emacs 25]].
В GNU Emacs 24 и более ранних версиях эмакса этой настройки нет;
придется добавить ее самим.

#+name: package-system-backports
#+begin_src elisp
  (unless (boundp 'package-selected-packages)
    (defcustom package-selected-packages (list)
      "Store here packages installed explicitly by user."
      :type '(repeat symbol)
      :group 'package))
#+end_src

В новых версиях эмакса с опцией package-selected-packages связано
гораздо больше функциональности, чем имело бы смысл портировать в
старые версии эмакса. Но функция package-install-selected-packages
того стоит --- она автоматически устанавливает ваши любимые пакеты, по
списку.

#+name: package-system-backports
#+begin_src elisp
  (unless (fboundp #'package-install-selected-packages)
    (defun package-install-selected-packages ()
      "Ensure packages in `package-selected-packages' are installed."
      (interactive)
      (let ((packages-to-be-installed (cl-remove-if #'package-installed-p package-selected-packages)))
        (when packages-to-be-installed
          (when (or noninteractive
                   (y-or-n-p (format "%s packages will be installed:\n%s, proceed?"
                               (length packages-to-be-installed)
                               (mapconcat #'symbol-name packages-to-be-installed ", "))))
            (mapc #'package-install packages-to-be-installed))))))
#+end_src

Кроме ручной установки пакетов из графического интерфейса, нам
понадобится средство для автоматической установки и грамотной загрузки
установленных пакетов.
В настоящее время для этой цели сообщество использует лисп-программу
[[https://github.com/jwiegley/use-package][use-package]].

#+name: make-sure-use-package-package-will-be-present
#+begin_src elisp
  (unless (cl-find 'use-package package-selected-packages)
    (cl-pushnew 'use-package package-selected-packages)
    (customize-save-variable-after-init package-selected-packages))
#+end_src

[[elisp:(customize-group-other-window 'use-package)][Use Package]]⊲
[[elisp:(customize-variable-other-window 'use-package-always-ensure)][Use Package Always Ensure]]
← [[elisp:(customize-save-variable 'use-package-always-ensure t)][устанавливать пакеты лисп-программой use-package]]
без необходимости использования ключа :ensure в коде вызова.

#+name: setup-use-package
#+begin_src elisp
  (unless use-package-always-ensure
    (setq use-package-always-ensure t)
    (customize-save-variable-after-init use-package-always-ensure))
#+end_src

На этом описание основной части программы инициализации
завершено. Дальнейший текст рассказывает о важных стандартных
настройках, нестандартных сочетаниях клавиш и конфигурации
установленных пакетов.

----------------------------------------------------------------------

Идейный преемник проекта
[[https://github.com/technomancy/emacs-starter-kit][Emacs Starter Kit]] ---
проект [[https://github.com/technomancy/better-defaults][Better Defaults]],
выполнен [[http://technomancy.us/][Филом Хагельбергом]]
[[[http://sachachua.com/blog/2014/05/emacs-chat-phil-hagelberg/][интервью]]]
в виде пакета с небольшой лисп-программой. Эта лисп-программа, каждая
строка которой тщательно отобрана сообществом, устанавливает значения
пары десятков стандартных параметров в обход стандартной системы
управления этими параметрами. Трудно найти более противоречивый
проект. В некотором смысле это образцово-показательный забег по
граблям. На мой взгляд, если современный Starter Kit стал гайдом, то
логично было бы сделать гайдом и Better Defaults. Ниже я привожу
ссылки на настройки некоторых ключевых параметров эмакса с
пояснением причин по которым их стоит сделать. Списки сделанных
настроек показывают лисп-программы
[[elisp:customize-saved][M-x customize-saved]] и
[[elisp:customize-unsaved][M-x customize-unsaved]]. Конечно, система
кастомизации не всемогуща и для некоторых настроек (например,
нестандартные сочетания клавиш) придется написать несколько строк на
лиспе. В общем виде весь последующий код выглядит так:

#+name: load-packages-and-apply-advanced-customizations
#+begin_src elisp
  <<definitions>>
  <<customizations>>
  <<keybindings>>
#+end_src

Начнем кастомизацию эмакса сверху и продолжим последовательно
углубляться во всё более тонкие аспекты его работы. Но прежде --- для
удобства и быстроты настройки --- лучше
[[elisp:(customize-variable-other-window 'org-confirm-elisp-link-function)][Org Confirm Elisp Link Function]]
← [[elisp:(customize-save-variable 'org-confirm-elisp-link-function nil)][не подтверждать выполнение лисп-кода при переходе по ссылкам в этом руководстве]] и
[[elisp:(customize-variable-other-window 'org-return-follows-link)][Org Return Follows Link]]
← [[elisp:(customize-save-variable 'org-return-follows-link t)][переходить по ссылкам нажатием на Enter]].

[[elisp:(describe-variable 'frame-title-format)][Frame Title Format]]
← имя буфера или полное имя файла/директории предваренное именем
пользователя и машины при удаленном подключении. Как ни странно,
заголовок фрейма (окна в оконном менеджере операционной системы) не
кастомизируется стандартными средствами. Если открыто несколько
фреймов, заголовок по-умолчанию совершенно бесполезен, поэтому
используем наипростейший формат, позволяющий отличить один фрейм от
другого.

#+name: customizations
#+begin_src elisp
  (setq-default frame-title-format
   '(:eval (concat (when (file-remote-p default-directory)
                     (let ((user (file-remote-p default-directory 'user))
                           (host (file-remote-p default-directory 'host)))
                       (format "%s@%s:" user host)))
                   (or buffer-file-truename dired-directory (buffer-name)))))
#+end_src

[[elisp:(customize-variable-other-window 'menu-bar-mode)][Menu Bar Mode]]
← [[elisp:(customize-save-variable 'menu-bar-mode nil)][главное меню спрятано]].
80% опций в главном меню эмакса никогда не используются, остальные 20%
продублированы в меню моделайна (/mode-line /--- /строка режимов/ под
окном буфера). Меню буферов вызывается сочетаниями C-F10 и
C-Left-Click в любом месте буфера, глобальное меню --- по
C-Right-Click, само главное меню --- клавишей F10. Разумнее всего
спрятать главное меню и показывать его при необходимости сочетанием
C-x F10 (вариант C-M-F10 не подходит для Cygwin и Linux).

#+name: keybindings
#+begin_src elisp
  (global-set-key (kbd "C-x <f10>") #'toggle-menu-bar-mode-from-frame)
#+end_src

[[elisp:(customize-variable-other-window 'tool-bar-mode)][Tool Bar Mode]]
← [[elisp:(customize-save-variable 'tool-bar-mode nil)][панель инструментов отключена]].
Панель инструментов в эмаксе абсолютно бесполезна.

[[elisp:(customize-variable-other-window 'scroll-bar-mode)][Scroll Bar Mode]]
← [[elisp:(customize-save-variable 'scroll-bar-mode 'right)][полоса прокрутки справа]].
Многие [[elisp:(customize-save-variable 'scroll-bar-mode nil)][отключают полосу прокрутки]]
по трем причинам: она не является частью стандартного интерфейса
эмакса, она плохо реализована и эстетически убога. Но в то же время,
нельзя отрицать ее очевидную пользу в графических средах даже в таком
неполноценном виде.

[[elisp:(customize-variable-other-window 'window-divider-mode)][Window Divider Mode]]
← [[elisp:(customize-save-variable 'window-divider-mode nil)][широкая вертикальная разделительная черта между окнами отключена]].
[[elisp:(customize-save-variable 'window-divider-mode t)][Разделение окон по горизонтали широкой вертикальной чертой]]
позволяет легко менять размеры окон мышкой при включенных полосах
прокрутки. Выглядит старомодно, но в группе
[[elisp:(customize-group-other-window 'window-divider)][Window Divider]]
есть настройки стиля.

[[elisp:(customize-face-other-window 'fringe)][Fringe face]]
← [[elisp:(let ((bg `(:background ,(face-attribute 'default :background))))(face-spec-set 'fringe `((t ,bg)))(put 'fringe 'theme-face `((user ,bg)))(put 'fringe 'saved-face `((t ,bg)))(custom-save-all))][прозрачные поля]].
Во всех текстовых редакторах начиная с Блокнота принято иметь
небольшие поля по краям области редактирования текста. Поля
обязательно должны быть цвета фона чтобы не акцентировать внимание на
артефактах рендеринга полосы прокрутки.
[[elisp:(customize-themes)][Цветовые темы]] эмакса меняют цвета фона и
полей, поэтому каждый раз при изменении темы нам нужно чтобы цвет
полей соответствовал цвету фона. Для этого используем средство
[[https://en.wikipedia.org/wiki/Aspect-oriented_programming][аспектно-ориентированного программирования]]
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html#Advising-Functions][Advice]],
которое изменяет поведение функций сторонних лисп-программ без
изменения их оригинальной реализации. Функции-аспекты должны иметь как
минимум такой же список аргументов, что и оригинальные функции, но
байт-компилятор будет ругаться, если эти аргументы не будут
использоваться, поэтому
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Lexical-Binding.html][имена неиспользуемых аргументов должны начинаться с подчеркивания]].

#+name: customizations
#+begin_src elisp
  (let ((set-transparent-fringe
         (lambda (&rest _)
          (set-face-background 'fringe (face-attribute 'default :background)))))
    (advice-add #'load-theme :after set-transparent-fringe)
    (advice-add #'disable-theme :after set-transparent-fringe))
#+end_src

[[elisp:(customize-variable-other-window 'indicate-empty-lines)][Indicate Empty Lines]]
← [[elisp:(customize-save-variable 'indicate-empty-lines nil)][нет штриховки на полях]].
[[elisp:(customize-save-variable 'indicate-empty-lines t)][Штриховка на полях]]
изящно выделяет пустую область за гранью буфера, но иногда отвлекает.

[[elisp:(customize-variable-other-window 'uniquify-buffer-name-style)][Uniquify Buffer Name Style]]
← [[elisp:(customize-save-variable 'uniquify-buffer-name-style 'post-forward)][за именами одинаковых буферов следует часть файлового пути]].

[[elisp:(customize-variable-other-window 'uniquify-separator)][Uniquify Separator]]
← [[elisp:(customize-save-variable 'uniquify-separator "\\")][имена одинаковых буферов отделены обратным слешем \ от файлового пути]].

[[elisp:(customize-variable-other-window 'size-indication-mode)][Size Indication Mode]]
← [[elisp:(customize-save-variable 'size-indication-mode t)][в моделайне отображается размер буфера]].

[[elisp:(customize-variable-other-window 'line-number-mode)][Line Number Mode]]
← [[elisp:(customize-save-variable 'line-number-mode t)][в моделайне отображается номер строки]] на которой находится курсор.

[[elisp:(customize-variable-other-window 'column-number-mode)][Column Number Mode]]
← [[elisp:(customize-save-variable 'column-number-mode t)][в моделайне отображается номер столбца]] на котором находится курсор.

[[elisp:(customize-variable-other-window 'initial-buffer-choice)][Initial Buffer Choice]]
← [[elisp:(customize-save-variable 'initial-buffer-choice 'remember-notes)][после запуска эмакс открывает файл с заметками]]
вместо стартового экрана, или как вариант ---
[[elisp:(customize-save-variable 'initial-buffer-choice t)][после запуска эмакс открывает =*scratch*=-буфер]].
По желанию эмакс может открыть любой файл, директорию, сайт, программу
для чтения почты, новостей, чат, командную оболочку операционной
системы, музыкальный проигрыватель или новый закон природы.

[[elisp:(customize-variable-other-window 'remember-notes-initial-major-mode)][Remember Notes Initial Major Mode]]
← [[elisp:(customize-save-variable 'remember-notes-initial-major-mode 'nil)][эмакс открывает файл с заметками в режиме по-умолчанию]],
[[elisp:(customize-save-variable 'remember-notes-initial-major-mode 'text-mode)][в режиме text-mode]]
или [[elisp:(customize-save-variable 'remember-notes-initial-major-mode 'org-mode)][в режиме org-mode]].
По умолчанию [[elisp:(customize-variable-other-window 'initial-major-mode)][режим по-умолчанию]] ---
lisp-interaction-mode; поэтому предполагается, что это будут заметки с
лисп-кодом для эмакса. В группе кастомизации
[[elisp:(customize-group 'remember 'other-window)][Remember]] можно указать
[[elisp:(customize-variable-other-window 'remember-data-file)][расположение файла с заметками]]
и много других вещей.

[[elisp:(customize-variable-other-window 'initial-scratch-message)][Initial Scratch Message]]
← что угодно или [[elisp:(customize-save-variable 'initial-scratch-message nil)][ничего]]. Эмакс
[[http://www.gnu.org/software/emacs/manual/html_node/elisp/Startup-Summary.html][всегда]]
открывает =*scratch*=-буфер после запуска.  От него невозможно
избавиться, но можно сделать
[[http://ergoemacs.org/emacs/modernization_scratch_buffer.html][более полезным]],
если добавить в него несколько ссылок на домашнюю директорию,
[[http://www.juev.org/2009/08/10/emacs-password-manager/][файл с личными паролями зашифрованный эмаксом]]
с помощью
[[https://ru.wikipedia.org/wiki/GnuPG][GNU Privacy Guard]], активные проекты, сайты и прочее.

#+name: customizations
#+begin_src elisp
  (add-hook 'emacs-startup-hook
    (defun well-tuned-emacs-scratch-buffer-message ()
      (with-current-buffer "*scratch*"
        (let ((scratch-buf-last-char (point-max)))
          (goto-char scratch-buf-last-char)
          (fancy-splash-insert
           :link (list "File" (lambda (_button) (call-interactively #'find-file))
                       "Specify a new file's name, to edit the file")
           " "
           :link (list "Home" (lambda (_button) (dired "~"))
                       "Open home directory, to operate on its files")
           " "
           :link (list "Passwords" (lambda (_button)
                                     (let ((passwords "~/Dropbox/Passwords.org.gpg"))
                                       (when (file-exists-p passwords)
                                         (find-file passwords))))
                       "Open encrypted password vault"))
          (comment-region scratch-buf-last-char (point))
          (newline)
          (goto-char (point-max))
          (set-buffer-modified-p nil)))))
#+end_src

--------------------------------------------------------------------------------

[[elisp:(customize-variable-other-window 'cursor-type)][Cursor Type]]
← классический [[elisp:(customize-save-variable 'cursor-type t)][прямоугольный сплошной курсор]] или
современная [[elisp:(customize-save-variable 'cursor-type 'bar)][вертикальная черта между букв]].
[[Http://raskin-interface.narod.ru/interface/chapter5.htm#s5.5][Классический курсор предпочтительнее]]:
он заметнее на больших экранах. Однако, при выделении текста такой
курсор полностью перекрывает выделенную область под собой и из-за
этого нельзя понять, выделен ли символ под курсором --- до тех пор
пока курсор не пропадет. Если курсор не мигает, эта задача и вовсе
неразрешима. В качестве решения этой проблемы непрозрачный сплошной
курсор можно сделать прозрачным после активации
[[http://www.gnu.org/software/emacs/manual/html_node/emacs/Mark.html][метки]]
(inactive→active), а после деактивации метки (active→inactive) сделать
его обратно сплошным:

| i | → | a | a | → | i |
|---+---+---+---+---+---|
| ■ | → | □ | □ | → | ■ |
| ■ | → | □ | ␣ |   | ␣ |
| ␣ |   | ␣ | □ |   | □ |
| ␣ |   | ␣ | ␣ |   | ␣ |

Решение интересное, но не обязательное.

#+begin_src elisp
  (let (inactive-mark-cursor-type)
    (add-hook 'activate-mark-hook
      (defun alter-cursor-type-after-activate-mark ()
        (pcase (setq inactive-mark-cursor-type cursor-type)
          ('box (unless blink-cursor-mode (setq cursor-type 'hollow))))))
    (add-hook 'deactivate-mark-hook
      (defun alter-cursor-type-after-deactivate-mark ()
        (pcase inactive-mark-cursor-type
          ('box (pcase cursor-type
                  ('hollow (setq cursor-type 'box))))))))
#+end_src

[[elisp:(customize-variable-other-window 'blink-cursor-mode)][Blink Cursor Mode]]
← [[elisp:(customize-save-variable 'blink-cursor-mode t)][курсор мигает]].

[[elisp:(customize-variable-other-window 'make-pointer-invisible)][Make Pointer Invisible]]
← [[elisp:(customize-save-variable 'make-pointer-invisible t)][курсор мыши прячется при вводе текста]].

[[elisp:(customize-variable-other-window 'global-hl-line-mode)][Global Hl Line Mode]]
← [[elisp:(customize-save-variable 'global-hl-line-mode nil)][текущая строка не подсвечивается]]
или [[elisp:(customize-save-variable 'global-hl-line-mode t)][подсвечивается]] ---
когда это действительно необходимо.

[[elisp:(customize-variable-other-window 'visible-bell)][Visible Bell]]
← [[elisp:(customize-save-variable 'visible-bell t)][в качестве предупреждения эмакс мерцает, а не звенит]].
Без этой настройки попытка сдвинуть курсор в пустом буфере вызовет
раздражительный громкий звон.

[[elisp:(customize-variable-other-window 'save-place-mode)][Save Place Mode]]
← [[elisp:(customize-save-variable 'save-place-mode t)][позиция курсора в буфере сохраняется между сессиями]].
После открытия файла редактирование продолжается с того места где было
закончено.

[[elisp:(customize-variable-other-window 'save-place-file)][Save Place File]]
← [[elisp:(customize-save-variable 'save-place-file (concat user-emacs-directory "places"))][позиции курсоров сохраняются в файле ~/.emacs.d/places]].

[[elisp:(customize-variable-other-window 'require-final-newline)][Require Final Newline]]
← [[elisp:(customize-save-variable 'require-final-newline t)][в конец сохраняемого файла добавляется пустая строка]].

[[elisp:(customize-variable-other-window 'backup-directory-alist)][Backup Directory Alist]]
← [[elisp:(customize-save-variable 'backup-directory-alist `(("." . ,(concat user-emacs-directory "backup"))))][резервные копии файлов хранятся в директории ~/.emacs.d/backup]].
В противном случае резервные копии будут захламлять директории в
которых находятся редактируемые файлы.

[[elisp:(customize-variable-other-window 'global-auto-revert-mode)][Global Auto Revert Mode]]
← [[elisp:(customize-save-variable 'global-auto-revert-mode t)][буфер автоматически перезагружает содержимое файла при его изменении внешними программами]].

[[elisp:(customize-variable-other-window 'delete-by-moving-to-trash)][Delete By Moving To Trash]]
← [[elisp:(customize-save-variable 'delete-by-moving-to-trash t)][удаленные эмаксом файлы отправляются в корзину операционной системы]].

[[elisp:(customize-variable-other-window 'ido-mode)][Ido Mode]] &
[[elisp:(customize-variable-other-window 'ido-everywhere)][Ido Everywhere]]
← [[elisp:(progn (customize-save-variable 'ido-mode 'both) (customize-save-variable 'ido-everywhere t))][интерактивная навигация в минибуфере]] 
при работе с файлами и буферами.

[[elisp:(customize-variable-other-window 'ido-enable-flex-matching)][Ido Enable Flex Matching]]
← [[elisp:(customize-save-variable 'ido-enable-flex-matching t)][более удобный поиск и выбор из множества вариантов]]
во время интерактивной навигации в минибуфере.

[[elisp:(customize-variable-other-window 'ido-save-directory-list-file)][Ido Save Directory List File]]
← [[elisp:(customize-save-variable 'ido-save-directory-list-file (concat user-emacs-directory "ido"))][состояние лисп-программы ido сохраняется в файле ~/.emacs.d/ido]].

[[elisp:(customize-variable-other-window 'ido-ubiquitous-mode)][Ido Ubiquitous Mode]]
← [[elisp:(customize-save-variable 'ido-ubiquitous-mode 1)][интерактивная навигация в минибуфере]]
при почти любом автодополнении. У этой лисп-программы есть
[[https://github.com/DarwinAwardWinner/ido-ubiquitous/pull/96][некоторые проблемы]] 
(которые были исправлены прямо во время написания этого предложения с
помощью пул реквеста на гитхабе и вечером того же дня все пользователи
Emacs получили свои копии этого пакета уже без бага --- суть философии
разработки Emacs).

#+name: customizations
#+begin_src elisp
  (use-package ido-ubiquitous
    :config (reinstate-mode 'ido-ubiquitous-mode))
#+end_src

[[elisp:(customize-group 'smex 'other-window)][Smex]] ---
интерактивная навигация в минибуфере при работе с M-x-командами
эмакса.

#+name: customizations
#+begin_src elisp
  (use-package smex
    :bind (("M-x" . smex)
           ("M-X" . smex-major-mode-commands)
           ("C-c C-c M-x" . execute-extended-command)))
#+end_src

[[elisp:(customize-variable-other-window 'smex-save-file)][Smex Save File]]
← [[elisp:(customize-save-variable 'smex-save-file (concat user-emacs-directory "smex"))][состояние лисп-программы smex сохраняется в файле ~/.emacs.d/smex]].

[[elisp:(customize-group "mule" 'other-window)][MULE Internationalization]]⊲
[[elisp:(customize-variable-other-window 'default-input-method)][Default Input Method]]
← [[elisp:(customize-save-variable 'default-input-method "russian-computer")][русский язык]].
Эмакс использует независимое от операционной системы переключение
языков и [[elisp:(call-interactively #'set-input-method)][методов ввода]]
для обеспечения своей работы в очень разных средах. Переключение на
русский язык по C-\ без предварительного указания метода ввода требует
кастомизации. Кроме национальных методов ввода текста есть
технические, например TeX (шутка в духе [[https://en.wikipedia.org/wiki/Donald_Knuth][профессора]]),
в этих режимах введенные спецслова превращаются в спецсимволы,
например \​'e → é, \​th → þ, \​Mu\​epsilon\​nu → Μεν,
\existsa\forallb(b\ina) → ∃a∀b(b∈a).

C-\ не самое удобное сочетание клавиш, как вариант можно использовать
свободное сочетание Shift-Space.

#+name: keybindings
#+begin_src elisp
  (global-set-key (kbd "S-SPC") #'toggle-input-method)
  (define-key isearch-mode-map (kbd "S-SPC") #'isearch-toggle-input-method)
#+end_src

--------------------------------------------------------------------------------

Для эмакса написано много лисп-программ делающих работу со скобками
более удобной и наглядной. Режимы
[[elisp:(customize-variable-other-window 'electric-pair-mode)][Electric Pair Mode]] и
[[elisp:(customize-variable-other-window 'show-paren-mode)][Show Paren Mode]] ---
это встроенные лисп-программы, они достаточно хороши, но есть и
получше, например [[https://github.com/Fuco1/smartparens][Smartparens]] и
[[http://emacswiki.org/emacs/ParEdit][Paredit]].
Однако все эти программы устарели, поэтому не стоит заморачиваться с
их настройкой. Современные экспериментальные программы вроде
[[http://shaunlebron.github.io/parinfer/][Parinfer]]
определяют структуру программы по отступам в коде и расставляют скобки
автоматически.

#+name: customizations
#+begin_src elisp
  (use-package smartparens-config :ensure smartparens
    :diminish smartparens-mode
    :config
      (progn
        <<bind-some-keys-for-smartparens-mode>>
        <<turn-on-smartparens-mode-for-some-modes>>
        (reinstate-mode 'smartparens-global-mode)
        (reinstate-mode 'show-smartparens-global-mode)))
#+end_src

[[elisp:(customize-variable-other-window 'smartparens-global-mode)][Smartparens Global Mode]]
← [[elisp:(customize-save-variable 'smartparens-global-mode nil)][скобки вводятся по-отдельности]] или [[elisp:(customize-save-variable 'smartparens-global-mode t)][парами во всех режимах]].
Необязательно включать этот режим везде, по-настоящему он полезен
только при редактировании структурированного кода.

#+name: turn-on-smartparens-mode-for-some-modes
#+begin_src elisp
  (add-hook 'prog-mode-hook #'turn-on-smartparens-strict-mode)
#+end_src

[[elisp:(customize-variable-other-window 'show-smartparens-global-mode)][Show Smartparens Global Mode]]
← [[elisp:(customize-save-variable 'show-smartparens-global-mode t)][парные скобки подсвечиваются]].

Smartparens включает в себя несколько альтернативных наборов сочетаний
клавиш для манипуляции
[[https://en.wikipedia.org/wiki/S-expression][символьными выражениями]]
(см. [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][анимированное руководство]]).
У каждого из этих наборов есть некоторые недостатки, поэтому я
использую традиционный набор, свободный от этих недостатков насколько
это позволяют незанятые клавиши эмакса и здравый смысл.

#+name: bind-some-keys-for-smartparens-mode
#+begin_src elisp
  (bind-keys :map smartparens-mode-map
    <<classic-TI-Explorer-Zmacs-keys>>
    <<arrow-naviagion>>
    <<slurp/barf>>
    <<splice/unwrap>>
    ("C-k" . sp-kill-hybrid-sexp))
#+end_src

Текстовый редактор
[[https://en.wikipedia.org/wiki/Zmacs][Zmacs]] в 80-х использовался как IDE для Common Lisp и
[[https://en.wikipedia.org/wiki/Lisp_Machine_Lisp][ZetaLisp]] на
[[https://en.wikipedia.org/wiki/Lisp_machine][лисп-машинах]] 
[[https://en.wikipedia.org/wiki/TI_Explorer][Texas Instruments Explorer]]
и имел богатый репертуар команд для работы с символьными выражениями:

#+name: classic-TI-Explorer-Zmacs-keys
#+begin_src elisp
  ("C-M-f" . sp-forward-sexp)
  ("C-M-b" . sp-backward-sexp)
  ("C-M-n" . sp-next-sexp)
  ("C-M-p" . sp-previous-sexp)
  ("C-M-u" . sp-backward-up-sexp)
  ("C-M-d" . sp-down-sexp)
  ("C-M-(" . sp-beginning-of-sexp)
  ("C-M-)" . sp-end-of-sexp)
  ("C-M-t" . sp-transpose-sexp)
  ("C-M-<backspace>" . sp-backward-kill-sexp)
  ("C-M-k" . sp-kill-sexp)
  ("C-M-w" . sp-copy-sexp)
#+end_src

Консистентная навигация по S-выражениям стрелками.

#+name: arrow-naviagion
#+begin_src elisp
  ("C-M-<up>" . sp-backward-up-sexp)
  ("C-M-<down>" . sp-down-sexp)
  ("C-M-<left>" . sp-backward-sexp)
  ("C-M-<right>" . sp-forward-sexp)
#+end_src

Команды сдвига скобок в соответствующих направлениях продублированы на
случай если в терминале не работают стрелки.

#+name: slurp/barf
#+begin_src elisp
  ("C-<left>" . sp-backward-slurp-sexp)
  ("C-<right>" . sp-forward-slurp-sexp)
  ("M-<left>" . sp-forward-barf-sexp)
  ("M-<right>" . sp-backward-barf-sexp)
  ("C-," . sp-backward-slurp-sexp)
  ("C-." . sp-forward-slurp-sexp)
  ("C-M-," . sp-forward-barf-sexp)
  ("C-M-." . sp-backward-barf-sexp)
#+end_src

Сплайсы и удаления скобок поднимают S-выражение на уровень выше в
дереве S-выражений, или делают его структуру более плоской.

#+name: splice/unwrap
#+begin_src elisp
  ("C-<up>" . sp-splice-sexp-killing-around)
  ("C-<down>" . sp-splice-sexp)
  ("M-[" . sp-backward-unwrap-sexp)
  ("M-]" . sp-unwrap-sexp)
#+end_src

Пусть удаление слова назад (см. [[backward-kill-word-or-kill-region][C-w --- backward-kill-word-or-kill-region]])
сохраняет структуру S-выражений.

#+name: customizations
#+begin_src elisp
  (advice-add #'backward-kill-word-or-kill-region :around
    (defun backward-kill-word-preserve-s-expression-structure (fn &rest args)
      (if (when smartparens-mode (not (region-active-p)))
          (sp-backward-kill-word (cl-first args))
        (apply fn args))))
#+end_src

--------------------------------------------------------------------------------

[[elisp:(customize-variable-other-window 'indent-tabs-mode)][Indent Tabs Mode]]
← [[elisp:(customize-save-variable 'indent-tabs-mode nil)][отступы пробелами]].

[[elisp:(customize-variable-other-window 'tab-always-indent))][Tab Always Indent]]
← [[elisp:(customize-save-variable 'tab-always-indent 'complete)][после автоматической установки отступов Tab выполняет автодополнение]].

[[elisp:(customize-variable-other-window 'subword-mode)][Subword Mode]]
← [[elisp:(customize-save-variable 'subword-mode t)][составные части слова записанного CamelCase'ом считаются отдельными словами]].
[[http://ergoemacs.org/emacs/emacs_subword-mode_superword-mode.html][Подробнее у Xah Lee]].

[[elisp:(customize-variable-other-window 'superword-mode)][Superword Mode]]
← [[elisp:(customize-save-variable 'superword-mode t)][составные слова набранные в любом стиле считаются одним словом]].
Режимы Subword и Superword взаимно исключают друг
друга. Одновременно может быть активен только один из режимов.

[[elisp:(customize-variable-other-window 'delete-selection-mode)][Delete Selection Mode]]
← [[elisp:(customize-save-variable 'delete-selection-mode t)][выделенный текст полностью удаляется или заменяется при удалении, вставке или вводе]].
Стандартное поведение современных текстовых редакторов.

[[elisp:(customize-variable-other-window 'mouse-yank-at-point)][Mouse Yank At Point]]
← [[elisp:(customize-save-variable 'mouse-yank-at-point t)][мышь вставляет текст на позиции текстового курсора]],
а не на позиции курсора мыши. В традиции
[[https://en.wikipedia.org/wiki/X_Window_System][X Window System]]
текст вставляется по щелчку средней кнопки мыши.

X Window System и Emacs (в любой ОС) поддерживают два буфера обмена:
/primary/ и /clipboard/. Мышь работает с primary-буфером, клавиатурные
команды --- с clipboard-буфером.

[[elisp:(customize-variable-other-window 'x-select-enable-clipboard t)][X Select Enable Clipboard]]
← [[elisp:(customize-save-variable 'x-select-enable-clipboard t)][клавиатурные команды копирования и вставки используют системный буфер обмена]]
(по-умолчанию).

[[elisp:(customize-variable-other-window 'x-select-enable-primary)][X Select Enable Primary]]
← [[elisp:(customize-save-variable 'x-select-enable-primary t)][клавиатурные команды копирования и вставки используют мышиный буфер обмена]]
(в дополнение к системному).

[[elisp:(customize-variable-other-window 'save-interprogram-paste-before-kill)][Save Interprogram Paste Before Kill]]
← [[elisp:(customize-save-variable 'save-interprogram-paste-before-kill t)][фрагменты текста скопированные в буфер обмена во внешних программах сохраняются в эмаксе]]
в буфере скопированных и удаленных фрагментов текста
[[http://www.gnu.org/software/emacs/manual/html_node/emacs/Yanking.html][kill ring]].

[[elisp:(describe-function #'yes-or-no-p)][Yes or No Predicate]]
← подтверждение одной клавишей: Y или Пробел --- да, N или Delete ---
нет.

#+name: customizations
#+begin_src elisp
  (defalias (function yes-or-no-p) (function y-or-n-p))
#+end_src

[[elisp:(customize-variable-other-window 'apropos-do-all)][Apropos Do All]]
← [[elisp:(customize-save-variable 'apropos-do-all t)][расширенный поиск команд, функций, переменных и документации командами apropos]].

# [[elisp:(customize-variable-other-window ')][]]
# ← [[elisp:(customize-save-variable ')][]]

--------------------------------------------------------------------------------

О настройке режима Org можно написать целую книгу, но есть несколько
простых опций, которые полезны для работы с этим руководством.

[[elisp:(customize-variable-other-window 'org-support-shift-select)][Org Support Shift Select]]
← [[elisp:(customize-save-variable 'org-support-shift-select t)][выделение шифтом и стрелками в режиме Org]].

[[elisp:(customize-variable-other-window 'org-src-fontify-natively)][Org Src Fontify Natively]]
← [[elisp:(customize-save-variable 'org-src-fontify-natively t)][код в блоках подсвечивается как обычный текст]].

[[elisp:(customize-variable-other-window 'org-src-window-setup)][Org Src Window Setup]]
← по C-c ' [[elisp:(customize-save-variable 'org-src-window-setup 'current-window)][редактор кода открывается в окне документа]] или
[[elisp:(customize-save-variable 'org-src-window-setup 'reorganize-frame)][в отдельном окне]] (по-умолчанию).

[[elisp:(customize-variable-other-window 'org-confirm-babel-evaluate)][Org Confirm Babel Evaluate]]
← [[elisp:(customize-save-variable 'org-confirm-babel-evaluate nil)][код в блоках выполняется без предварительного подтверждения]].

--------------------------------------------------------------------------------

Настройка шрифтов в эмаксе очень специфична и системно-зависима. С
учетом всего разнообразия операционных систем и окружений в которых
может работать эмакс, в нем невозможно настроить шрифты стандартными
средствами так чтобы они работали везде должным образом. Следующие
настройки позволят эмаксу использовать шрифт лучше всего подходящий
его окружению.

[[elisp:(customize-variable-other-window 'well-tuned-emacs-fonts)][Well Tuned Emacs Fonts]]
← списки предпочитаемых шрифтов в разных системных окружениях. Это
ассоциативный список в котором множеству системных окружений
соответствует множество шрифтов в порядке предпочтения.

#+name: customize-well-tuned-emacs
#+begin_src elisp
  (defcustom well-tuned-emacs-fonts
    (quote
     (((gnu/linux gnu/kfreebsd darwin windows-nt cygwin)
       "Consolas-10" "Courier New-9" "Monaco-9" "Anonymous Pro-11"
       "Cambria-11" "Times New Roman-11" "Georgia-10" "DejaVu Serif Condensed-10"
       "Arial-10" "Droid Sans-10" "Segoe UI Symbol-10" "Lucida Sans Unicode-10" "Corbel-11"
       "Droid Sans Mono-10" "Envy Code R-10" "Menlo-10")
      ((gnu/linux gnu/kfreebsd)
       "Inconsolata-10" "DejaVu Sans Mono-10" "Ubuntu Mono-10")))
    "Preferred fonts for operating system environments."
    :type '(alist
            :key-type
            (set :tag "Type of operating system"
                 (const :tag "A GNU/Linux system—that is, a variant GNU system, using the Linux kernel." gnu/linux)
                 (const :tag "A GNU (glibc-based) system with a FreeBSD kernel." gnu/kfreebsd)
                 (const :tag "The GNU system (using the GNU kernel, which consists of the HURD and Mach)." gnu)
                 (const :tag "Darwin (Mac OS X)." darwin)
                 (const :tag "Microsoft Windows NT, 9X and later." windows-nt)
                 (const :tag "Cygwin, a Posix layer on top of MS-Windows." cygwin)
                 (const :tag "Microsoft’s DOS." ms-dos))
            :value-type (repeat :tag "Preferred fonts"
                                (string :tag "Font")))
    :version "25.0.50.1"
    :group 'well-tuned-emacs)
#+end_src

Соответствующая функция возвращает список предпочитаемых шрифтов в
текущем системном окружении.

#+name: customize-well-tuned-emacs
#+begin_src elisp
  (defun well-tuned-emacs-fonts ()
    (cl-loop for (systems . fonts) in well-tuned-emacs-fonts
             when (member system-type systems) append fonts into system-fonts
             finally return (cl-remove-duplicates system-fonts :test #'equal :from-end t)))
#+end_src

_available-font_ → полное имя шрифта, если шрифт с указанным кратким
именем доступен в текущем системном окружении. _Осторожно_: применение
функции find-font в консольном Emacs 24.5.1 под Debian Stretch 64
приведет к ошибке сегментации и краху программы.

#+name: customize-well-tuned-emacs
#+begin_src elisp
  (defun available-font (font)
    (when (stringp font) 
      (when window-system (find-font (font-spec :name font)))))
#+end_src

_available-well-tuned-emacs-fonts_ → список предпочитаемых шрифтов
доступных в текущем системном окружении.

#+name: customize-well-tuned-emacs
#+begin_src elisp
  (defun available-well-tuned-emacs-fonts ()
    (cl-remove-if-not #'available-font (well-tuned-emacs-fonts)))
#+end_src

[[elisp:(customize-variable-other-window 'well-tuned-emacs-fonts)][Well Tuned Emacs Font]]
← выбранный пользователем шрифт для каждого конкретного системного
окружения. По-умолчанию выбирается наиболее предпочтительный шрифт из
доступных в текущем системном окружении.

#+name: customize-well-tuned-emacs
#+begin_src elisp
  (defcustom well-tuned-emacs-font
    (list (cons system-type (cl-first (available-well-tuned-emacs-fonts))))
    "Chosen fonts for operating systems."
    :type '(alist
            :key-type
            (choice :tag "Type of operating system"
                    (const :tag "A GNU/Linux system—that is, a variant GNU system, using the Linux kernel." gnu/linux)
                    (const :tag "A GNU (glibc-based) system with a FreeBSD kernel." gnu/kfreebsd)
                    (const :tag "The GNU system (using the GNU kernel, which consists of the HURD and Mach)." gnu)
                    (const :tag "Darwin (Mac OS X)." darwin)
                    (const :tag "Microsoft Windows NT, 9X and later." windows-nt)
                    (const :tag "Cygwin, a Posix layer on top of MS-Windows." cygwin)
                    (const :tag "Microsoft’s DOS." ms-dos))
            :value-type (string :tag "Font"))
    :set 
    (progn
      <<well-tuned-emacs-font>>
      (lambda (symbol value)
        (when (listp value)
          (set symbol value)
          (well-tuned-emacs-font (well-tuned-emacs-font)))))
    :version "25.0.50.1"
    :group 'well-tuned-emacs)
#+end_src

Соответствующая функция устанавливает или возвращает выбранный
пользователем шрифт для текущего системного окружения.

#+name: well-tuned-emacs-font
#+begin_src elisp
  (defun well-tuned-emacs-font (&optional font)
    (let ((current-font (cdr (assoc system-type well-tuned-emacs-font))))
      (or (unless font current-font)
          (when (stringp font)
            (unless (equal font current-font)
              (setq well-tuned-emacs-font
                   (cl-subst (cons system-type font) (cons system-type current-font)
                              well-tuned-emacs-font :test #'equal)))
            (when (available-font font)
              (set-frame-font font :keep-size t))))))
#+end_src

Быстро выбрать шрифт можно двумя способами: автодополнением по имени
шрифта через сочетание клавиш C-x M-f [«Meta-Font»]

#+name: keybindings
#+begin_src elisp
  (global-set-key (kbd "C-x M-f")
    (defun select-font ()
      (interactive)
      (well-tuned-emacs-font
       (completing-read "Select font: " (available-well-tuned-emacs-fonts)))))
#+end_src

или последовательно перебирая доступные шрифты сочетаниями клавиш C-x
C-[</>] и далее С-[</>] или [</>] до тех пор, пока не будет найден
нужный шрифт (аналогично выбору размера шрифта программой
[[elisp:(describe-function #'text-scale-adjust)][text-scale-adjust]] по C-x C-[+/−]).

#+name: keybindings
#+begin_src elisp
  (defun adjust-font (inc)
    (interactive "p")
    (well-tuned-emacs-font 
     (or (cycle-around (well-tuned-emacs-font)
                       (pcase (event-basic-type last-command-event)
                         ((or ?< ?,) (- inc))
                         ((or ?> ?.) inc)
                         (_ inc))
                       (available-well-tuned-emacs-fonts))
         (cl-first (available-well-tuned-emacs-fonts))))
    (message (format "%s. Use < and > for further adjustment."
               (well-tuned-emacs-font)))
    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (dolist (mod '(() (control)))
         (dolist (key '(?< ?> ?, ?.))
           (define-key map (vector (append mod (list key)))
             (lambda () (interactive) (adjust-font (abs inc))))))
       map)))
#+end_src

#+name: keybindings
#+begin_src elisp
  (cl-loop for key in '(?< ?> ?, ?.) do
    (define-key ctl-x-map (vector (list 'control key)) #'adjust-font))
#+end_src

Цикл по последовательности вокруг элемента заключается в выборе
/другого/ элемента последовательности отстоящего от указанного на
некоторое количество позиций. Указанный элемент может быть результатом
выбора только если последовательность не содержит никаких других
элементов.

#+name: definitions
#+begin_src elisp
  (cl-defun cycle-around (item times seq &key (test #'equal))
    (if (zerop times) item
      (let ((times (if (cl-plusp times) (1- times) times)))
        (cl-loop for (i . tail) on seq collect i into head
                 when (funcall test i item) return
                 (let ((cycle (cl-remove item (append tail head) :test test)))
                   (or (when cycle (nth (mod times (length cycle)) cycle))
                       (unless cycle item)))))))
#+end_src

Дополнительно можно добавить выбор из всех доступных семейств шрифтов
по C-x C-M-f

#+name: keybindings
#+begin_src elisp
  (global-set-key (kbd "C-x C-M-f")
    (defun select-font-family ()
      (interactive)
      (well-tuned-emacs-font
       (completing-read "Select font: " (font-families)))))
#+end_src

и переключение между ними по C-x M-[</>] и C-x C-M-[</>].

#+name: keybindings
#+begin_src elisp
  (defun adjust-font-family (inc)
    (interactive "p")
    (well-tuned-emacs-font 
     (or (cycle-around (font-family (well-tuned-emacs-font))
                       (pcase (event-basic-type last-command-event)
                         ((or ?< ?,) (- inc))
                         ((or ?> ?.) inc)
                         (_ inc))
                       (font-families))
         (cl-first (font-families))))
    (message (format "%s. Use < and > for further adjustment."
               (well-tuned-emacs-font)))
    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (dolist (mod '(() (meta) (control meta)))
         (dolist (key '(?< ?> ?, ?.))
           (define-key map (vector (append mod (list key)))
             (lambda () (interactive) (adjust-font-family (abs inc))))))
       map)))
#+end_src

#+name: keybindings
#+begin_src elisp
  (cl-loop for key in '(?< ?> ?, ?.) do
    (cl-loop for mod in '((meta) (control meta)) do
      (define-key ctl-x-map (vector (append mod (list key))) #'adjust-font-family)))
#+end_src

_font-families_ → упорядоченный список всех доступных семейств шрифтов.

#+name: definitions
#+begin_src elisp
  (defun font-families ()
    (funcall 
     (compose
      (lambda (font-families) (sort font-families (lambda (x y) (string< (upcase x) (upcase y)))))
      (lambda (font-families) (cl-remove-duplicates font-families :test #'string=))
      (lambda (font-families) (cl-remove-if-not #'available-font font-families)))
     (font-family-list)))
#+end_src

_font-family_ → семейство к которому принадлежит указанный шрифт.

#+name: definitions
#+begin_src elisp
  (defun font-family (font-name)
    (when font-name
      (funcall 
       (compose
        (function symbol-name)
        (lambda (font-spec) (font-get font-spec :family))
        (lambda (font-name) (font-spec :name font-name)))
       font-name)))
#+end_src

_compose_ → [[https://en.wikipedia.org/wiki/Function_composition][композиция функций]]:

#+begin_center
(compose e f … g h) = e ∘ f ∘ … ∘ g ∘ h = λx.e(f(…(g(hx)))
#+end_center

основа кода этой функции взята из книги
“[[https://7chan.org/pr/src/ANSI_Common_Lisp_-_Paul_Graham.pdf][ANSI Common Lisp]]” (1995), 
автор --- [[http://www.paulgraham.com/][Paul Graham]] (см. [[http://www.paulgraham.com/acl.html][о книге на сайте автора]]);
страница 110. Можно считать это просто рекомендацией
хорошей книги основателя [[http://news.ycombinator.com][news.ycombinator.com]].
Занятно: 20 лет назад, всего через 8 месяцев после выхода Windows 95
вышла книга в которой автор рассказывает о практическом применении
выразительных средств которые впоследствии станут мейнстримом только через
15-20 лет. Еще более занятно то, что все эти средства уже тогда можно
было использовать в древнем даже по тем временам текстовом редакторе
двадцатилетней давности.

#+name: definitions
#+begin_src elisp
  (defun compose (&rest functions)
    (cl-destructuring-bind (first . rest) (reverse functions)
      (lambda (&rest args)
        (cl-reduce (apply-partially #'flip #'funcall) rest :initial-value (apply first args)))))
#+end_src

Фрагмент (lambda (v f) (funcall f v)) в оригинальном коде Пола Грэма
показался мне недостаточно изящным и быстрый поиск в интернете указал
на маленькую полезную абстракцию:

_flip_ → результат применения функции при перемене мест
аргументов. Эта функция определена в стандарте
[[https://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009][Haskell 2010: Chapter 9. Standart Prelude]]:

#+begin_verse
  -- flip f  takes its (first) two arguments in the reverse order of f.  
  flip             :: (a → b → c) → b → a → c
  flip f x y       =  f y x
#+end_verse

#+name: definitions
#+begin_src elisp
  (defun flip (f x y) (funcall f y x))
#+end_src

--------------------------------------------------------------------------------

Сочетания клавиш в эмаксе имеют три ярко выраженные особенности: их
очень много; их трудно запомнить; и они вызывают повреждения рук при
злоупотреблении. С запоминанием помогут
[[https://www.gnu.org/software/emacs/refcards/index.html][быстрые подсказки в формате PDF]]:
«[[https://www.gnu.org/software/emacs/refcards/pdf/ru-refcard.pdf][Справочник команд GNU Emacs]]»,
«[[https://www.gnu.org/software/emacs/refcards/pdf/orgcard.pdf][Org-Mode Reference Card]]»,
«[[https://www.gnu.org/software/emacs/refcards/pdf/dired-ref.pdf][Dired Reference Card]]»;
и лисп-программа [[https://github.com/kai2nenobu/guide-key][Guide Key]].

#+name: customizations
#+begin_src elisp
  (use-package guide-key
    :diminish guide-key-mode
    :config (reinstate-mode 'guide-key-mode))
#+end_src

[[elisp:(customize-variable-other-window 'guide-key-mode)][Guide Key Mode]] &
[[elisp:(customize-variable-other-window 'guide-key/guide-key-sequence)][Guide Key Sequence]]
← [[elisp:(customize-save-variable 'guide-key-mode t)][автоматически показывать доступные сочетания клавиш]] 
для префиксов
C-x [[[elisp:(progn (dolist (k '("C-x" "C-x RET" "C-x ." "C-x @" "C-x a" "C-x a i" "C-x M-k" "C-x C-k" "C-x n" "C-x r" "C-x v" "C-x 4" "C-x 5" "C-x 6" "C-x 8" "C-x 8 a" "C-x 8 \"" "C-x 8 '" "C-x 8 *" "C-x 8 ," "C-x 8 /" "C-x 8 1" "C-x 8 2" "C-x 8 3" "C-x 8 N" "C-x 8 ^" "C-x 8 _" "C-x 8 `" "C-x 8 ~")) (cl-pushnew k guide-key/guide-key-sequence :test #'equal))(customize-save-variable 'guide-key/guide-key-sequence guide-key/guide-key-sequence))][добавить]]],
C-c [[[elisp:(customize-save-variable 'guide-key/guide-key-sequence (cl-pushnew "C-c" guide-key/guide-key-sequence :test #'equal))][добавить]]],
C-h [[[elisp:(progn (dolist (k '("C-h" "C-h 4")) (cl-pushnew k guide-key/guide-key-sequence :test #'equal))(customize-save-variable 'guide-key/guide-key-sequence guide-key/guide-key-sequence))][добавить]]],
M-s [[[elisp:(progn (dolist (k '("M-s" "M-s h")) (cl-pushnew k guide-key/guide-key-sequence :test #'equal))(customize-save-variable 'guide-key/guide-key-sequence guide-key/guide-key-sequence))][добавить]]],
M-g [[[elisp:(customize-save-variable 'guide-key/guide-key-sequence (cl-pushnew "M-g" guide-key/guide-key-sequence :test #'equal))][добавить]]],
F** [[[elisp:(progn (dolist (k (list (string ?< ?f ?1 ?>) (string ?< ?f ?1 ?> ?  ?4) (string ?< ?f ?2 ?>))) (cl-pushnew k guide-key/guide-key-sequence :test #'equal))(customize-save-variable 'guide-key/guide-key-sequence guide-key/guide-key-sequence))][добавить]]],
ESC [[[elisp:(progn (dolist (k '("ESC" "M-ESC")) (cl-pushnew k guide-key/guide-key-sequence :test #'equal))(customize-save-variable 'guide-key/guide-key-sequence guide-key/guide-key-sequence))][добавить]]].

[[elisp:(customize-variable-other-window 'guide-key/popup-windows-position)][Guide Key Popup Window Position]]
← [[elisp:(customize-save-variable 'guide-key/popup-windows-position 'bottom)][окно с подсказками сочетаний клавиш появляется снизу]]
или [[elisp:(customize-save-variable 'guide-key/popup-windows-position 'right)][справа]] (по-умолчанию).

Для снижения нагрузки на левую руку при вводе команд
эмакса многие люди советуют
[[http://www.emacswiki.org/emacs/MovingTheCtrlKey][поменять местами клавиши Caps Lock и Control]].
Раньше я тоже так делал, но этого явно недостаточно. На современных
стандартных клавиатурах кнопку Caps Lock нажимать удобнее, чем
Control, но это не избавляет от нагрузки на левую руку, а всего лишь
незначительно снижает ее. Лучше полностью отказаться от клавиш Control
и Caps Lock и использовать в качестве модификатора «C-» зажатую
клавишу «пробел». Решение не идеальное, но для здоровья рук оно
полезнее, чем Caps ⇆ Ctrl.

<<backward-kill-word-or-kill-region>>
Сочетание клавиш C-w --- де-факто стандарт для удаления слова слева от
курсора.

#+name: definitions
#+begin_src elisp
  (defun backward-kill-word-or-kill-region (arg)
    (interactive "p")
    (if (region-active-p)
        (kill-region (region-beginning) (region-end))
      (backward-kill-word arg)))
#+end_src

#+name: keybindings
#+begin_src elisp
  (global-set-key (kbd "C-w") #'backward-kill-word-or-kill-region)
  (define-key isearch-mode-map (kbd "C-w") #'backward-kill-word-or-kill-region)
  (define-key minibuffer-local-map (kbd "C-w") #'backward-kill-word-or-kill-region)
  (add-hook 'ido-setup-hook
    (defun well-tuned-emacs-bind-ido-mode-delete-backward-word-updir ()
      (when (boundp 'ido-completion-map)
        (when (fboundp #'ido-delete-backward-word-updir)
          (define-key ido-completion-map (kbd "C-w") #'ido-delete-backward-word-updir)))))
#+end_src

Поиск по шаблонам регулярных выражений более актуален в качестве поиска по-умолчанию.

#+name: keybindings
#+begin_src elisp
  (global-set-key (kbd "C-s") #'isearch-forward-regexp)
  (global-set-key (kbd "C-r") #'isearch-backward-regexp)
  (global-set-key (kbd "C-M-s") #'isearch-forward)
  (global-set-key (kbd "C-M-r") #'isearch-backward)
#+end_src

Быстрое переключение между режимами Org и Text по M-F1 и M-F2 для удобного
редактирования этого руководства.

#+name: keybindings
#+begin_src elisp
  (with-eval-after-load "text-mode"
    (when (boundp 'text-mode-map)
      (define-key text-mode-map (kbd "M-<f2>") #'org-mode)))
  (with-eval-after-load 'org
    (when (boundp 'org-mode-map)
      (define-key org-mode-map (kbd "M-<f1>") #'text-mode)))
#+end_src

Логичнее удалять текст /до/ буквы, чем /до-с/ буквой.

#+name: keybindings
#+begin_src elisp
  (autoload #'zap-up-to-char "misc"
    "Kill up to, but not including ARGth occurrence of CHAR." t)
  (global-set-key (kbd "M-z") #'zap-up-to-char)
#+end_src

Лисп-программа [[elisp:ibuffer][ibuffer]] это улучшенная версия программы управления
буферами [[elisp:list-buffers][list-buffers]].

#+name: keybindings
#+begin_src elisp
  (global-set-key (kbd "C-x C-b") #'ibuffer)
#+end_src

Для быстрого убийства буфера хорошо подходит сочетание C-x
C-k. По-умолчанию на него назначен очень редко используемый набор
сочетаний клавиш для отладки макросов, который логично смотрится на
месте свободного сочетания C-x M-k [«keyboard macro»-команды].

#+name: keybindings
#+begin_src elisp
  (global-set-key (kbd "C-x C-k") #'kill-this-buffer)
  (global-set-key (kbd "C-x M-k") #'kmacro-keymap)
#+end_src

Автодополнение текста выполняется программой hippie-expand, которая
включает в себя стандартную программу автодополнения dabbrev-expand и
несколько других программ, выдающих дополнения определенного вида в
желаемом порядке.

#+name: keybindings
#+begin_src elisp
  (global-set-key (kbd "M-/") #'hippie-expand)
#+end_src

[[elisp:(customize-variable-other-window 'hippie-expand-try-functions-list)][Hippie Expand Try Functions List]]
← [[elisp:(customize-save-variable 'hippie-expand-try-functions-list '(try-expand-all-abbrevs try-complete-file-name-partially try-complete-file-name try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-dabbrev-all-buffers try-expand-list try-expand-line try-complete-lisp-symbol-partially try-complete-lisp-symbol))][мощная, но умеренная последовательность вариантов автодополнений Саши]] или
[[elisp:(customize-save-variable 'hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line try-complete-lisp-symbol-partially try-complete-lisp-symbol))][просто умеренная последовательность автодополнений Божидара]].
Оригинальная последовательность автодополнений иногда выдает варианты
с небывалым размахом.

Команда [[elisp:unfill-paragraph][unfill-paragraph]], назначенная на свободное сочетание C-x M-q,
делает ровно противоположное команде [[elisp:fill-paragraph][fill-paragraph]] (M-q) --- она
превращает абзац разбитый на несколько коротких строк в одну большую
строку.

#+name: keybindings
#+begin_src elisp
  (global-set-key (kbd "C-x M-q")
    (defun unfill-paragraph (&optional region)
      "Takes a multi-line paragraph and makes it into a single line of text."
      (interactive (progn (barf-if-buffer-read-only) (list t)))
      (let ((fill-column (point-max)))
        (fill-paragraph nil region))))
#+end_src

----------------------------------------------------------------------

В [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-HOME.html][Windows 7/8/10]]
эмакс по-умолчанию считает своей домашней директорией значение
переменной окружения

#+begin_center
{~} → (getenv "AppData") → C:\Users\User\AppData\Roaming
#+end_center

в то время как в UNIX-совместимых ОС подразумевается
директория

#+begin_center
{~} → (getenv "UserProfile") → C:\Users\User
#+end_center

Эмакс будет считать своей домашней директорией путь прописанный в
переменной окружения Home, если она определена. Её значение можно
изменить с помощью [[http://ss64.com/nt/][команды Windows]] [[http://ss64.com/nt/setx.html][setx]].

#+begin_src elisp
  (when (eq system-type 'windows-nt)
    (unless (getenv "Home")
      (shell-command (format "setx \"%s\" \"%s\"" 'Home (getenv "UserProfile")))))
#+end_src

Установка домашней рабочей директории (cd "~") --- в свойствах ярлыка
«Рабочая папка».

----------------------------------------------------------------------

Исправления некоторых багов GNU Emacs:

[[http://wenshanren.org/?p=781][Emacs 25 testing: org-html-export returns org-html-fontify-code: Wrong number of arguments…]]

#+name: fix-some-bugs
#+begin_src elisp
  (when (= emacs-major-version 25)
    (declare-function font-lock-fontify-buffer "font-lock" ())
    (defun org-font-lock-ensure ()
      (font-lock-fontify-buffer)))
#+end_src

----------------------------------------------------------------------

Роман Захаров [[mailto:zahardzhan@gmail.com][zahardzhan@gmail.com]].

#+name: header
#+begin_src elisp
  ;; Copyright © Roman Zaharov <zahardzhan@gmail.com>

  ;; This file is not part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 3, or (at your option)
  ;; any later version. 

  ;;; Code:

#+end_src

#+name: footer
#+begin_src elisp
  (provide 'well-tuned-emacs)
#+end_src
